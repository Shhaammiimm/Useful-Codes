#include<bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;
#define ll long long
#define hello() ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
#define nl "\n"
#define yes cout<<"YES"<<nl
#define no cout<<"NO"<<nl
#define ss second
#define ff first
#define all(v) v.begin(),v.end()
#define eb emplace_back
#define sz(x) (int)(x).size()
#define pb push_back
#define mod 1000000007
#define mem(a,x) memset(a,x,sizeof(a))
#define dbg(args...) do {cerr << #args << " : "; faltu(args); } while(0)
void faltu () {            cerr << endl;}
template < typename T, typename ... hello>void faltu( T arg, const hello &... rest) {cerr << arg << ' ';faltu(rest...);}
const int N=2e5+123;
ll prop[4*N],a[N];
bool vis[4*N];
void lazy(int id,int b,int e){
 prop[id]=(e-b+1)-prop[id];
 if(b!=e){
 vis[id*2]^=1;
 vis[2*id+1]^=1;
 }
 vis[id]=0;
}
void init(ll id,ll b,ll e){
  if(b==e){
    prop[id]=a[b];return;
  }
  ll mid=(b+e)/2;
  init(id*2,b,mid);
  init(id*2+1,mid+1,e);
}
void update(ll id,ll b,ll e,ll i,ll j){
    if(vis[id]){
      lazy(id,b,e);
    }
  if(b>j || e<i)return;
  if(b>=i && e<=j){
    prop[id]=(e-b+1)-prop[id];
    if(b!=e){
     vis[id*2]^=1;
     vis[2*id+1]^=1;
    }
    return;
  }
  ll mid=(b+e)>>1;
  update(id*2,b,mid,i,j);
  update(id*2+1,mid+1,e,i,j);
   prop[id]=prop[2*id]+prop[2*id+1];
   return;
}
ll query(ll id,ll b,ll e,ll i,ll j){
    if(vis[id]){
        lazy(id,b,e);
    }
    if(b>j || e<i)return 0;

    if(b>=i  && e<=j){
        return prop[id];
    }
    ll mid=(b+e)>>1;
    ll left=query(id*2,b,mid,i,j);
    ll right=query(id*2+1,mid+1,e,i,j);
   // dbg(leftsum,rightsum);
    return left+right;
}
int main()
{
  hello();
  int n,q;cin>>n>>q;
 // for(int i=1;i<=n;i++)cin>>a[i];
  //init(1,1,n);
  while(q--){
    ll k,a,b;
    cin>>k>>a>>b;
    if(k==0){
        update(1,1,n,a,b);
    }
    else{
        cout<<query(1,1,n,a,b)<<nl;
    }
  }
}
//8
//2 3 5 1 10 11 8 9

